"""
Sample TensorFlow XML-to-TFRecord converter

optional arguments:
  -h, --help            show this help message and exit
  -x XML_DIR, --xml_dir XML_DIR
                        Path to the folder where the input .xml files are stored.
  -l LABELS_PATH, --labels_path LABELS_PATH
                        Path to the labels (.pbtxt) file.
  -o OUTPUT_PATH, --output_path OUTPUT_PATH
                        Path of output TFRecord (.record) file.
  -i IMAGE_DIR, --image_dir IMAGE_DIR
                        Path to the folder where the input image files are stored. Defaults to the same directory as XML_DIR.
  -c CSV_PATH, --csv_path CSV_PATH
                        Path of output .csv file. If none provided, then no file will be written.
"""
import glob
import io
import os
import xml.etree.ElementTree as ET
from collections import namedtuple
from typing import Dict, Any

import pandas as pd
from PIL import Image
from object_detection.utils import dataset_util, label_map_util

from config.config import Config

os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"  # Suppress TensorFlow logging (1)
import tensorflow.compat.v1 as tf


def xml_to_csv(path):
    """Iterates through all .xml files (generated by labelImg) in a given directory and combines
    them in a single Pandas dataframe.

    Parameters:
    ----------
    path : str
        The path containing the .xml files
    Returns
    -------
    Pandas DataFrame
        The produced dataframe
    """
    xml_list = []
    for xml_file in glob.glob(path + "/*.xml"):
        tree = ET.parse(xml_file)
        root = tree.getroot()
        filename = root.find("filename").text
        width = int(root.find("size").find("width").text)
        height = int(root.find("size").find("height").text)

        for member in root.findall("object"):
            bounding_box = member.find("bndbox")
            xml_list.append(
                (
                    filename,
                    width,
                    height,
                    member.find("name").text,
                    int(bounding_box.find("xmin").text),
                    int(bounding_box.find("ymin").text),
                    int(bounding_box.find("xmax").text),
                    int(bounding_box.find("ymax").text),
                )
            )

    column_name = ["filename", "width", "height", "class", "xmin", "ymin", "xmax", "ymax"]
    xml_df = pd.DataFrame(xml_list, columns=column_name)
    return xml_df


def class_text_to_int(row_label, label_map_dict):
    return label_map_dict[row_label]


def split(df, group):
    data = namedtuple("data", ["filename", "object"])
    gb = df.groupby(group)
    return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]


def create_tf_example(group, path, labels_path: str):
    label_map = label_map_util.load_labelmap(labels_path)
    label_map = label_map_util.get_label_map_dict(label_map)

    with tf.gfile.GFile(os.path.join(path, "{}".format(group.filename)), "rb") as fid:
        encoded_jpg = fid.read()

    encoded_jpg_io = io.BytesIO(encoded_jpg)
    image = Image.open(encoded_jpg_io)
    width, height = image.size

    filename = group.filename.encode("utf8")
    image_format = b"jpg"
    xmins = []
    xmaxs = []
    ymins = []
    ymaxs = []
    classes_text = []
    classes = []

    for index, row in group.object.iterrows():
        xmins.append(row["xmin"] / width)
        xmaxs.append(row["xmax"] / width)
        ymins.append(row["ymin"] / height)
        ymaxs.append(row["ymax"] / height)
        classes_text.append(row["class"].encode("utf8"))
        classes.append(class_text_to_int(row["class"], label_map))

    return tf.train.Example(
        features=tf.train.Features(
            feature={
                "image/height": dataset_util.int64_feature(height),
                "image/width": dataset_util.int64_feature(width),
                "image/filename": dataset_util.bytes_feature(filename),
                "image/source_id": dataset_util.bytes_feature(filename),
                "image/encoded": dataset_util.bytes_feature(encoded_jpg),
                "image/format": dataset_util.bytes_feature(image_format),
                "image/object/bbox/xmin": dataset_util.float_list_feature(xmins),
                "image/object/bbox/xmax": dataset_util.float_list_feature(xmaxs),
                "image/object/bbox/ymin": dataset_util.float_list_feature(ymins),
                "image/object/bbox/ymax": dataset_util.float_list_feature(ymaxs),
                "image/object/class/text": dataset_util.bytes_list_feature(classes_text),
                "image/object/class/label": dataset_util.int64_list_feature(classes),
            }
        )
    )


def get_arguments(target: str = "train") -> Dict[str, Any]:
    return {
        # Path to the folder where the input .xml files are stored
        "xml_dir": Config.DATASET_PATH[target],
        # Path to the labels (.pbtxt) file
        "labels_path": Config.LABEL_MAP_PATH,
        # Path of output TFRecord (.record) file
        "output_path": Config.TF_RECORDS_PATH[target],
        # Path to the folder where the input image files are stored. " "Defaults to the same directory as XML_DIR.
        "image_dir": Config.DATASET_PATH[target],
        # Path of output .csv file. If none provided, then no file will be " "written.
        "csv_path": None,
    }


def main(_):
    train_set_args = get_arguments(target="train")
    test_set_args = get_arguments(target="test")

    for args in (train_set_args, test_set_args):
        writer = tf.python_io.TFRecordWriter(args["output_path"])
        path = os.path.join(args["image_dir"])
        examples = xml_to_csv(args["xml_dir"])
        grouped = split(examples, "filename")

        for group in grouped:
            tf_example = create_tf_example(group, path, args["labels_path"])
            writer.write(tf_example.SerializeToString())

        writer.close()
        print("Successfully created the TFRecord file: {}".format(args["output_path"]))

        if args["csv_path"] is not None:
            examples.to_csv(args["csv_path"], index=None)
            print("Successfully created the CSV file: {}".format(args["csv_path"]))


if __name__ == "__main__":
    tf.app.run()
